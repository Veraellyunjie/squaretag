#!/usr/bin/perl

use strict;
use warnings;

( my $app = $0 ) =~ s;.*/;;;

run(@ARGV) if !caller;

sub run {

    my $mode = shift;

    my %modes = (
        tag    => \&tag,
        clear  => \&clear,
        search => \&search,
        list   => \&list,
        rename => \&rename,
        mv     => \&rename,
    );

    if ( $mode && $modes{$mode} ) {
        $modes{$mode}->(@_);
    }
    else {
        warn "Usage: $app [tag|clear|list|search] ARGS\n";
        exit 1;
    }
    exit 0;
}

sub tag {
    my ( $tag_spec, @files ) = @_;
    my ( @add, @remove );

    if ( -e $tag_spec ) {
        warn "Tagspec is also a file?\n";
        exit 0;
    }

    for ( split( /,/, $tag_spec ) ) {
        next if /^\s*$/;
        if (/^-(.*)$/) {
            push @remove, $1;
        }
        elsif (/^\+?(.*)$/) {
            push @add, $1;
        }
    }

    if ( !@add && !@remove ) {
        exit 0;
    }

  FILE:
    for my $file (@files) {
        my ( $base, $tags, $ext ) = split_file($file);

        my ( @old_tags, @tags );
        @old_tags = @tags = split( /,/, $tags );

        if ( !@tags and !@add ) {
            next FILE;
        }

        push @tags, @add;
        my %tags = map { $_ => 1 } @tags;
        for (@remove) {
            delete $tags{$_};
        }
        @tags = sort keys %tags;

        my $new_file = "$base\[" . join( ',', @tags ) . "\]$ext";

        next FILE if $new_file eq $file;

        #print $file, " => ", $new_file,"\n";
        #next FILE;
        rename $file, $new_file;
    }
    return;
}

sub clear {
    my (@files) = @_;
    for my $file (@files) {
        my $new_file = remove_tags($file);
        rename $file, $new_file;
    }
    return;
}

sub search {
    my ( $tag_spec, @files ) = @_;
  FILE:
    for my $file (@files) {
        my ( $base, $tags, $ext ) = split_file($file);
        my @tags = split( /,/, $tags );
        my %tags = map { $_ => 1 } @tags;
        for ( split( /,/, $tag_spec ) ) {
            if (/^-(.*)$/) {
                next FILE if defined $tags{$1};
            }
            elsif (/^\+?(.*)$/) {
                next FILE if !defined $tags{$1};
            }
        }
        print $file, "\n";
    }
    return;
}

sub list {
    my (@files) = @_;
    my %tags;
    for my $file (@files) {
        my ( $base, $tags, $ext ) = split_file($file);
        my @tags = split( /,/, $tags );
        $tags{$_}++ for @tags;
    }
    for my $tag ( sort keys %tags ) {
        print "$tag $tags{$tag}\n";
    }
    return;
}

sub rename {
    my ( $old, $new, @files ) = @_;
  FILE:
    for my $file (@files) {
        my ( $base, $tags, $ext ) = split_file($file);
        my @tags = split( /,/, $tags );
        my %tags = map { $_ => 1 } @tags;
        if ( exists $tags{$old} ) {
            delete $tags{$old};
            $tags{$new} = 1;
            @tags = sort keys %tags;
            my $new_file = "$base\[" . join( ',', @tags ) . "\]$ext";
            rename $file, $new_file;
        }
    }
    return;

}

sub split_file {
    my $file = shift;
    my ( $base, $tags, $ext );
    ( $base, $ext )  = $file =~ m/^(.+?)(\.[^.]*$|$)/;
    ( $base, $tags ) = $base =~ m/^(.*?)(?:\[([^[]*)\]$|$)/;
    if ( !$base ) {
        $base = "[$tags]";
        $tags = '';
    }
    $ext  //= '';
    $tags //= '';
    return ( $base, $tags, $ext );
}

sub remove_tags {
    my $file = shift;
    my ( $base, $tags, $ext ) = split_file($file);
    return "$base$ext";
}

1;

__END__

=head1 NAME

squaretag - tag files by using filenames

=head1 SYNOPSIS

  squaretag tag TAG FILES...
  squaretag search SEARCH FILES...
  squaretag clear FILES...
  squaretag rename OLD_TAG NEW_TAG FILES...
  squaretag list FILES...

=head1 DESCRIPTION

Squaretag helps you to organize your files by tagging them. The tags
are saved in the filename by adding all tags in square brackets either
at the end of the filename or just before the last dot.

=head1 EXAMPLES

Suppose the current directory contains the following files:

  $ ls 
  picture01.jpg
  picture02

Now you want to add the tag I<family> to all pictures.

  $ squaretag tag family *

The filenames now contain the tag I<family>:

  $ ls
  picture01[family].jpg
  pciture02[family]

=head1 COMMANDS

=over 4

=item tag TAG FILES...

Add TAG to FILES.

=item search SPEC FILES...

List all FILES that match the search SPEC. SPEC is a comma seperated
list of search terms. A search term is either in the form I<tag> or
I<-tag>, either adding or removing all files that are or are not tagged
with I<tag>. Search terms are combined by I<AND>.

=item clear FILES...

Remove all tags from FILES.

=item rename OLD_TAG NEW_TAG FILES...

Rename OLD_TAG in NEW_TAG in all FILES.

=item list FILES...

List and count all tags for FILES. The tags are sorted in descending
order of frequency.

=back

=head1 COPYRIGHT AND LICENSE

Copyright 2016 Mario Domgoergen C<< <mario@domgoergen.com> >>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut
